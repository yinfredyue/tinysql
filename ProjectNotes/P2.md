# Project 2

For one information on reading `parser.y`, see the documentation at the beginning of the file. 

Essentially we need to make the parser able to parse the following join statements:

```sql
SELECT * from t2 join t3 on t2.id
select * from t1 join t2 left join t3 on t2.id = t3.id
select * from t1 right join t2 on t1.id = t2.id left join t3 on t3.id = t2.id
select * from t1 right join t2 on t1.id = t2.id left join t3
```

In `parser.y`, search for `Your code here`, and you can see the hint that we need to modify the grammar for `JoinTable`. Reading existing grammar, you see `ast.Join` node is used. The following two types are related: `DMLNode`, `SelectStmt`. 

Existing rule:

```
JoinTable:
	TableRef CrossOpt TableRef %prec tableRefPriority
	{
		$$ = &ast.Join{Left: $1.(ast.ResultSetNode), Right: $3.(ast.ResultSetNode), Tp: ast.CrossJoin}
	}
```

`%prec tableRefPriority`  changes the precedence of this rule `JoinTable: TableRef CrossOpt TableRef` to be the same as `tableRefPriority`. It has no other effect.

The following rules are as expected:

```
SelectStmt: SelectStmtFromTable OrderByOptional SelectStmtLimit
           | ...
SelectStmtFromTable: SelectStmtBasic "FROM" TableRefsClause WhereClauseOptional SelectStmtGroup HavingClause
TableRefsClause: TableRefs
TableRefs: EscapedTableRef
           | TableRefs ',' EscapedTableRef
EscaptedtableRef: TableRef
           | ...
TableRef: TableFactor JoinTable
TableFactor: TableName TableAsNameOpt IndexhintListOpt
           | ...
JoinTable: TableRef CorssOpt TableRef
JoinType: "LEFT"
           | "RIGHT"
CrossOpt: "JOIN"
           |	"INNER" "JOIN"
```

and loosely matched with the definitions:

```go
type SelectStmt struct {
	dmlNode

	// SelectStmtOpts wraps around select hints and switches.
	*SelectStmtOpts
	// Distinct represents whether the select has distinct option.
	Distinct bool
	// From is the from clause of the query.
	From *TableRefsClause
	// Where is the where clause in select statement.
	Where ExprNode
	// Fields is the select expression list.
	Fields *FieldList
	// GroupBy is the group by expression list.
	GroupBy *GroupByClause
	// Having is the having condition.
	Having *HavingClause
	// OrderBy is the ordering expression list.
	OrderBy *OrderByClause
	// Limit is the limit clause.
	Limit *Limit
	// TableHints represents the table level Optimizer Hint for join type
	TableHints []*TableOptimizerHint
	// IsInBraces indicates whether it's a stmt in brace.
	IsInBraces bool
}
```

Though not tested, the existing code can parse `SELECT * from t2 JOIN t3`.

Now it's clear that we need to make `JoinTable` support `ON` and `LEFT/RIGHT JOIN`. We can refer to the `parser.y` in TiDB, which is extremely similar to ours. Changes:

```diff
 JoinTable:
        TableRef CrossOpt TableRef %prec tableRefPriority
        {
                $$ = &ast.Join{Left: $1.(ast.ResultSetNode), Right: $3.(ast.ResultSetNode), Tp: ast.CrossJoin}
        }
-       /* Your code here. */
+|      TableRef CrossOpt TableRef "ON" Expression
+       {
+               on := &ast.OnCondition{Expr: $5}
+               $$ = &ast.Join{Left: $1.(ast.ResultSetNode), Right: $3.(ast.ResultSetNode), Tp: ast.CrossJoin, On: on}
+       }
+|      TableRef JoinType OuterOpt "JOIN" TableRef "ON" Expression
+       {
+               on := &ast.OnCondition{Expr: $7}
+               $$ = &ast.Join{Left: $1.(ast.ResultSetNode), Right: $5.(ast.ResultSetNode), Tp: $2.(ast.JoinType), On: on}
+       }

```







